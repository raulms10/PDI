% Solve a Pattern Recognition Problem with a Neural Network
% Script generated by Neural Pattern Recognition app
% Created Wed Nov 02 10:56:57 COT 2016
%
% This script assumes these variables are defined:
%
%   irisInputs - input data.
%   irisTargets - target data.
clear all;close all;clc 
%load('redNeuronal.mat');
C=8;
x = [];
tA = [];
tB = [];

nombre = ['00000'  '.ppm']; % Creamos el nombre de la imagen
img1 = imread(fullfile('.\Test',nombre));
[b,c,l,h] = componentes_color(img1);

figure(2); imshow(img1); impixelinfo;
figure(3); imshow(b); impixelinfo;

for i=0:9
    nombre = ['00000'  '.ppm']; % Creamos el nombre de la imagen
    img1 = imread(fullfile(['.\Train\0' num2str(i)],nombre)); % leemos la imagen y la pasamos a double
    a1 = img1;
    img1 = imresize(img1, [100 100]);
       
    cform=makecform('srgb2lab');
    a2=applycform(a1,cform);
    a2=normaliza(a2);
    c=a2(:,:,1);
    figure(4); imshow(c); impixelinfo;
    
    T = graythresh(c); %Calculamos el umbral en el que se puede binarizar la imagen, es como la intensidad de la imagen en escala de grises
    cI = im2bw(c, T); %Aplicamos el binarizado con el valor encontrado
    cI = imresize(cI, [300 300]);
    figure(5); imshow(cI); impixelinfo; %Mostramos la imagen binarizada
    
    cC = imclearborder(cI);        
    figure(6); imshow(cC); impixelinfo;
    
    
    
%     ee = strel('disk',1);
%     d = imtophat(c,ee);
%     d = imadjust(d);
%     figure(6); imshow(d); impixe+linfo;
%     b1 = edge(c, 'zerocross');
%     figure(7); imshow(b1); impixelinfo;
%     b2 = edge(c, 'Canny');
%     figure(8); imshow(b2); impixelinfo;
    pause;
    
    
%     c(c<120) = 0; %le aplicamos un umbral de 150 a la imagen y los hacemos 0
%     c(c>0) = 255; %y para los otros valores pongo 255
%     c = imclearborder(c);
   
    
   
    
    
%     ee = strel('disk', 1); %creamos nuestro elemento estructurante
%     c = imopen(c, ee); %hacemos una erosión y dilatación a la imagen
%     figure(5); imshow(c); impixelinfo;
%     pause;
%     
%     [l,n] = bwlabel(c); %sacamos la matriz de etiquetas a la imagen    
    

    [b,c,l,h] = componentes_color(img1);
    tA = [tA, b];
%     
    
    
    %img1=rgb2hsv(img1);
   
    
% %     nombre = ['00001'  '.ppm']; % Creamos el nombre de la imagen
% %     img2 = imread(fullfile(['.\Train\0' num2str(i)],nombre)); % leemos la imagen y la pasamos a double
% % %     img2 = imresize(img2, [100 100]);
% %     a2 = img2;
% %     
%     [b,c,l,h] = componentes_color(a1);
% %     img3=rgb2hsv(a1);
% %     img4=rgb2hsv(a2);
%     tA = [tA, b];
% %     [b,c,l,h] = componentes_color(a2);
% %     tB = [tB, b];
%     img = double(rgb2gray(img1));
%     %disp(img);
%     [Y, lambda, A, Xs] = pca(img,'NumComponents', C);%'Rows', 'all'); %Realiza un analisis PCA de img y retorna Xs con C caracteristicas(descritor)
%     [fil, col, cap] = size(img1);
%     fC = [];
%     roja1=0; verde1=0; azul1=0;
%     for f=1:fil
%         for c=1:col
%             roja1 = roja1 + double(img1(f,c,1));
%             verde1 = verde1 + double(img1(f,c,2));
%             azul1 = azul1 + double(img1(f,c,3));
%         end
%     end
%     comp1 = [roja1, verde1, azul1]/(fil*col/roja1);
% %     x = horzcat(x, comp1'); %Concatenamos el vector de caracteriscas de cada imagen
%     x = horzcat(x, lambda(1,:)');
    
end
% tT = [tA;tB];
figure(1); imshow(tA); impixelinfo;
% figure(2); imshow(tB); impixelinfo;
% figure(3); imshow(tT); impixelinfo;

%x = irisInputs;
t = xlsread('target.xlsx'); %Target de cada imagen

% Create a Pattern Recognition Network
% hiddenLayerSize = 10;
net = patternnet(10); %Creamos el tipo de red

% Setup Division of Data for Training, Validation, Testing
net.divideParam.trainRatio = 70/100;
net.divideParam.valRatio = 15/100;
net.divideParam.testRatio = 15/100;


% Train the Network
% [net,tr] = train(net,x,t); %Entramos y obtenemos la red

% v = x(:, 2);
% disp('dfsd');
% r = sim(net,v)
save('redNeuronal.mat'); %Guardamos la variables del workspace

%p = x(:,1); %Sacamos un valor del vector de caracteristicas
%y = net(p) %Probamos la red


% nntraintool;
% plotperform(tr);
% testX = x(:, tr.testInd);
% testT = t(:, tr.testInd);
% testY = net(testX);
% testYindices = vec2ind(testY);
% testTindices = vec2ind(testT);
% [c, cm] = confusion(testT, testY);
% plotconfusion(testT, testY);
